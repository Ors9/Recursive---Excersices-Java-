#BlueJ class context
comment0.target=RecursiveExams
comment0.text=\r\n\ There\ a\ list\ of\ Recursive\ excersice\ from\ the\ open\ university\r\n\ to\ use\ maximaize\ the\ usage\ click\ ctrl\ f\ and\ write\ the\ name\ of\ function\ you\ need\r\n\ to\ click\ ctrl\ f\ and\ find\ the\ excersice\ by\ function\ name\r\n\ @author\ (Or\ saban)\r\n\ @version\ (a\ version\ number\ or\ a\ date)\r\n
comment1.params=arr
comment1.target=int\ longestAlmostPalindrom(int[])
comment1.text=\r\n\ Finds\ the\ length\ of\ the\ longest\ almost\ palindrome\ subsequence\ in\ an\ array.\r\n\ An\ almost\ palindrome\ subsequence\ is\ a\ sequence\ that\ can\ be\ made\ into\ a\ palindrome\r\n\ by\ changing\ at\ most\ one\ element.\ \r\n\r\n\ @param\ arr\ The\ input\ array\r\n\ @return\ The\ length\ of\ the\ longest\ almost\ palindrome\ subsequence\r\n
comment10.params=mat
comment10.target=int\ maxPath(int[][])
comment10.text=\r\n\ Recursive\ function\ to\ find\ the\ maximum\ path\ sum\ in\ a\ matrix.\r\n\ This\ exercise\ is\ from\ 2022B\ moed\ 86.\r\n\r\n\ @param\ mat\ The\ input\ matrix.\r\n\ @return\ The\ maximum\ path\ sum\ in\ the\ matrix.\r\n
comment11.params=mat\ i\ j
comment11.target=int\ maxPath(int[][],\ int,\ int)
comment12.params=mat\ pattern
comment12.target=int\ lengthPath(char[][],\ java.lang.String)
comment12.text=\r\n\ Recursive\ function\ to\ find\ the\ length\ of\ the\ path\ in\ a\ matrix\ that\ matches\ a\ given\ pattern.\r\n\ This\ exercise\ is\ from\ 2022B\ moed\ 94.\r\n\r\n\ @param\ mat\ \ \ \ \ The\ input\ matrix.\r\n\ @param\ pattern\ The\ pattern\ to\ match.\r\n\ @return\ The\ length\ of\ the\ path\ in\ the\ matrix\ that\ matches\ the\ pattern.\r\n
comment13.params=mat\ pattern\ i\ j\ followMat
comment13.target=int\ lengthPath(char[][],\ java.lang.String,\ int,\ int,\ boolean[][])
comment14.params=pattern\ x\ i
comment14.target=boolean\ findChar(java.lang.String,\ char,\ int)
comment15.params=str1\ str2\ step
comment15.target=boolean\ isJump(java.lang.String,\ java.lang.String,\ int)
comment15.text=\r\n\ Recursive\ function\ to\ determine\ if\ one\ string\ can\ be\ transformed\ into\ another\ by\ jumping\ a\ fixed\ number\ of\ characters.\r\n\ This\ exercise\ is\ from\ 2022\ A\ moed\ 89.\r\n\r\n\ @param\ str1\ The\ source\ string.\r\n\ @param\ str2\ The\ target\ string.\r\n\ @param\ step\ The\ number\ of\ characters\ to\ jump\ in\ each\ step.\r\n\ @return\ True\ if\ str1\ can\ be\ transformed\ into\ str2\ by\ jumping\ a\ fixed\ number\ of\ characters,\ otherwise\ false.\r\n
comment16.params=str1\ str2\ step\ i\ j
comment16.target=boolean\ isJump(java.lang.String,\ java.lang.String,\ int,\ int,\ int)
comment17.params=str1\ str2
comment17.target=int\ strStep(java.lang.String,\ java.lang.String)
comment17.text=\r\n\ Recursive\ function\ to\ find\ the\ minimum\ number\ of\ steps\ required\ to\ transform\ str1\ into\ str2\ by\ jumping\ a\ fixed\ number\ of\ characters.\r\n\r\n\ @param\ str1\ The\ source\ string.\r\n\ @param\ str2\ The\ target\ string.\r\n\ @return\ The\ minimum\ number\ of\ steps\ required\ to\ transform\ str1\ into\ str2.\ If\ it's\ not\ possible\ to\ transform\ str1\ into\ str2,\ returns\ -1.\r\n
comment18.params=str1\ str2\ countStep
comment18.target=int\ strStep(java.lang.String,\ java.lang.String,\ int)
comment18.text=\r\n\ Recursive\ helper\ function\ to\ find\ the\ minimum\ number\ of\ steps\ required.\r\n\r\n\ @param\ str1\ \ \ \ \ \ \ The\ source\ string.\r\n\ @param\ str2\ \ \ \ \ \ \ The\ target\ string.\r\n\ @param\ countStep\ \ The\ current\ step\ count.\r\n\ @return\ The\ minimum\ number\ of\ steps\ required\ to\ transform\ str1\ into\ str2.\ If\ it's\ not\ possible\ to\ transform\ str1\ into\ str2\ within\ the\ given\ step\ count,\ returns\ -1.\r\n
comment19.params=mat\ x\ size
comment19.target=boolean\ isIdentity(int[][],\ int,\ int)
comment19.text=\r\n\ Recursive\ function\ to\ determine\ if\ a\ square\ sub-matrix\ within\ a\ larger\ matrix\ represents\ an\ identity\ matrix.\r\n\ This\ exercise\ is\ from\ 2022\ A\ moed\ 67.\r\n\r\n\ @param\ mat\ \ The\ matrix\ containing\ the\ sub-matrix\ to\ check.\r\n\ @param\ x\ \ \ \ The\ starting\ index\ of\ the\ sub-matrix.\r\n\ @param\ size\ The\ size\ of\ the\ square\ sub-matrix.\r\n\ @return\ True\ if\ the\ sub-matrix\ represents\ an\ identity\ matrix,\ otherwise\ false.\r\n
comment2.params=arr\ left\ right\ size
comment2.target=int\ longestAlmostPalindrom(int[],\ int,\ int,\ int)
comment2.text=\r\n\ Helper\ function\ to\ recursively\ find\ the\ longest\ almost\ palindrome\ subsequence.\r\n\r\n\ @param\ arr\ \ \ The\ input\ array\r\n\ @param\ left\ \ The\ left\ index\ of\ the\ current\ subsequence\r\n\ @param\ right\ The\ right\ index\ of\ the\ current\ subsequence\r\n\ @param\ size\ \ The\ size\ of\ the\ current\ subsequence\r\n\ @return\ The\ length\ of\ the\ longest\ almost\ palindrome\ subsequence\r\n
comment20.params=mat\ x\ size\ i\ j
comment20.target=boolean\ isIdentity(int[][],\ int,\ int,\ int,\ int)
comment21.params=mat
comment21.target=int\ maxMatrix(int[][])
comment21.text=\r\n\ Recursive\ function\ to\ find\ the\ maximum\ size\ of\ a\ square\ sub-matrix\ within\ a\ larger\ matrix\ that\ represents\ an\ identity\ matrix.\r\n\ This\ exercise\ is\ from\ 2022\ A\ moed\ 67.\r\n\r\n\ @param\ mat\ The\ matrix\ to\ analyze.\r\n\ @return\ The\ maximum\ size\ of\ a\ square\ sub-matrix\ representing\ an\ identity\ matrix.\r\n
comment22.params=mat\ x\ size
comment22.target=int\ maxMatrix(int[][],\ int,\ int)
comment23.params=arr\ num
comment23.target=int\ printExpr(int[],\ int)
comment23.text=\r\n\ Recursive\ function\ to\ print\ all\ possible\ arithmetic\ expressions\ using\ the\ elements\ of\ an\ array\ that\ evaluate\ to\ a\ given\ number.\r\n\ This\ exercise\ is\ from\ 2021B\ moed\ 92.\r\n\r\n\ @param\ arr\ The\ array\ of\ integers\ to\ use\ in\ the\ expressions.\r\n\ @param\ num\ The\ target\ number\ for\ the\ expressions\ to\ evaluate\ to.\r\n\ @return\ The\ total\ number\ of\ valid\ expressions\ found.\r\n
comment24.params=arr\ num\ i\ print\ sum
comment24.target=int\ printExpr(int[],\ int,\ int,\ java.lang.String,\ int)
comment25.params=lengths\ k\ num
comment25.target=int\ makeSum(int[],\ int,\ int)
comment25.text=\r\n\ Recursive\ function\ to\ count\ the\ number\ of\ ways\ to\ make\ a\ sum\ of\ numbers\ using\ a\ given\ set\ of\ lengths.\r\n\ This\ exercise\ is\ from\ 2020B\ moed\ 81.\r\n\r\n\ @param\ lengths\ An\ array\ representing\ the\ lengths\ of\ the\ numbers\ that\ can\ be\ used\ to\ make\ the\ sum.\r\n\ @param\ k\ \ \ \ \ \ \ The\ target\ sum\ to\ achieve.\r\n\ @param\ num\ \ \ \ \ The\ maximum\ number\ of\ elements\ that\ can\ be\ used.\r\n\ @return\ The\ number\ of\ ways\ to\ make\ the\ sum\ using\ the\ given\ lengths.\r\n
comment26.params=lengths\ k\ num\ i
comment26.target=int\ makeSum(int[],\ int,\ int,\ int)
comment27.params=arr
comment27.target=boolean\ split3(int[])
comment27.text=\r\n\ Recursive\ function\ to\ determine\ if\ an\ array\ can\ be\ split\ into\ three\ parts\ with\ equal\ sums.\r\n\ This\ exercise\ is\ from\ 2021B\ moed\ 60.\r\n\r\n\ @param\ arr\ The\ array\ to\ split.\r\n\ @return\ True\ if\ the\ array\ can\ be\ split\ into\ three\ parts\ with\ equal\ sums,\ otherwise\ false.\r\n
comment28.params=arr\ i\ sum1\ sum2\ sum3
comment28.target=boolean\ split3(int[],\ int,\ int,\ int,\ int)
comment29.params=arr
comment29.target=boolean\ equalSplit(int[])
comment29.text=\r\n\ Recursive\ function\ to\ determine\ if\ an\ array\ can\ be\ split\ into\ two\ parts\ with\ equal\ sum\ and\ equal\ lengths.\r\n\ This\ exercise\ is\ from\ 2021B\ moed\ 62.\r\n\r\n\ @param\ arr\ The\ array\ to\ split.\r\n\ @return\ True\ if\ the\ array\ can\ be\ split\ into\ two\ parts\ with\ equal\ sum\ and\ equal\ lengths,\ otherwise\ false.\r\n
comment3.params=str1\ str2
comment3.target=java.lang.String\ minimalSt(java.lang.String,\ java.lang.String)
comment3.text=\r\n\ Recursive\ function\ to\ find\ the\ minimal\ string\ between\ two\ input\ strings.\r\n\r\n\ @param\ str1\ The\ first\ input\ string.\r\n\ @param\ str2\ The\ second\ input\ string.\r\n\ @return\ The\ minimal\ string\ between\ str1\ and\ str2.\r\n
comment30.params=arr\ i\ sum1\ sum2\ sum1Length\ sum2Length
comment30.target=boolean\ equalSplit(int[],\ int,\ int,\ int,\ int,\ int)
comment31.params=mat
comment31.target=int\ minPrice(int[][])
comment31.text=\r\n\ Recursive\ function\ to\ find\ the\ minimum\ price\ path\ in\ a\ 2D\ matrix.\r\n\ This\ exercise\ is\ from\ 2021A\ moed\ 85\ corona.\r\n\r\n\ @param\ mat\ The\ matrix\ representing\ the\ prices.\r\n\ @return\ The\ minimum\ price\ to\ reach\ the\ last\ column\ from\ the\ first\ column.\r\n
comment32.params=mat\ i\ j
comment32.target=int\ minPrice(int[][],\ int,\ int)
comment33.params=mat
comment33.target=int\ maxSumKnight(int[][])
comment33.text=\r\n\ Recursive\ function\ to\ find\ the\ maximum\ sum\ that\ a\ knight\ can\ achieve\ in\ a\ chessboard.\r\n\ This\ exercise\ is\ from\ 2020B\ moed\ 98.\r\n\r\n\ @param\ mat\ The\ chessboard\ represented\ as\ a\ matrix.\r\n\ @return\ The\ maximum\ sum\ achievable\ by\ a\ knight\ starting\ from\ the\ top-left\ corner.\r\n
comment34.params=mat\ i\ j\ prev\ sum
comment34.target=int\ maxSumKnight(int[][],\ int,\ int,\ int,\ int)
comment35.params=mat\ k
comment35.target=int\ totalWays(int[][],\ int)
comment35.text=\r\n\ Recursive\ function\ to\ find\ the\ total\ number\ of\ ways\ to\ reach\ the\ bottom-right\ corner\ of\ a\ matrix\ with\ limited\ turns.\r\n\ This\ exercise\ is\ from\ 2020B\ moed\ 81.\r\n\r\n\ @param\ mat\ The\ matrix\ representing\ the\ path.\r\n\ @param\ k\ \ \ The\ maximum\ number\ of\ allowed\ turns.\r\n\ @return\ The\ total\ number\ of\ ways\ to\ reach\ the\ bottom-right\ corner\ with\ the\ given\ number\ of\ turns.\r\n
comment36.params=mat\ k\ i\ j\ before\ current
comment36.target=int\ totalWays(int[][],\ int,\ int,\ int,\ char,\ char)
comment37.params=mat
comment37.target=int\ findMaximum(int[][])
comment37.text=\r\n\ Recursive\ function\ to\ find\ the\ maximum\ sum\ achievable\ by\ moving\ through\ a\ matrix\ with\ blocked\ cells.\r\n\ This\ exercise\ is\ from\ 2020A\ moed\ 85.\r\n\r\n\ @param\ mat\ The\ matrix\ representing\ the\ grid\ with\ blocked\ cells\ denoted\ by\ -1.\r\n\ @return\ The\ maximum\ sum\ achievable\ by\ moving\ through\ the\ matrix.\r\n
comment38.params=mat\ i\ j
comment38.target=int\ findMaximum(int[][],\ int,\ int)
comment39.params=k\ n
comment39.target=int\ ways(int,\ int)
comment39.text=\r\n\ moed\ 2017B\ moed\ 84\r\n\r\n\ This\ method\ calculates\ the\ number\ of\ ways\ to\ reach\ a\ target\ 'n'\ by\ making\ 'k'\ moves.\r\n\ Each\ move\ can\ either\ increment\ or\ decrement\ the\ current\ value\ by\ 1.\r\n\r\n\ @param\ k\ The\ number\ of\ moves\ remaining.\r\n\ @param\ n\ The\ target\ value\ to\ reach.\r\n\ @return\ The\ number\ of\ ways\ to\ reach\ the\ target\ value\ within\ the\ given\ number\ of\ moves.\r\n
comment4.params=n
comment4.target=int\ countPairs(int)
comment4.text=\r\n\ Recursive\ function\ to\ count\ the\ number\ of\ valid\ pairs\ of\ parentheses.\r\n\ This\ exercise\ is\ from\ 2023A\ moed\ 65.\r\n\r\n\ @param\ n\ The\ number\ of\ pairs\ of\ parentheses\ to\ consider.\r\n\ @return\ The\ number\ of\ valid\ pairs\ of\ parentheses.\r\n
comment40.params=n
comment40.target=int\ oneFiveSeven(int)
comment40.text=\r\n\ moed\ 2017B\ moed\ 84\r\n\r\n\ This\ method\ calculates\ the\ minimum\ number\ of\ steps\ required\ to\ reach\ the\ target\ 'n'\r\n\ by\ adding\ 1,\ 5,\ or\ 7\ to\ the\ current\ sum\ in\ each\ step.\r\n\r\n\ @param\ n\ The\ target\ sum\ to\ reach.\r\n\ @return\ The\ minimum\ number\ of\ steps\ required\ to\ reach\ the\ target\ sum.\r\n
comment41.params=n\ sum
comment41.target=int\ oneFiveSeven(int,\ int)
comment42.params=arr
comment42.target=int\ midDiff(int[])
comment42.text=\r\n\ moed\ 2016A\ moed\ 87\r\n\r\n\ This\ method\ calculates\ the\ minimum\ difference\ between\ the\ sums\ of\ two\ subsets\r\n\ obtained\ by\ partitioning\ the\ given\ array\ 'arr'\ into\ two\ subsets.\r\n\r\n\ @param\ arr\ The\ input\ array\ of\ integers.\r\n\ @return\ The\ minimum\ absolute\ difference\ between\ the\ sums\ of\ two\ subsets.\r\n
comment43.params=arr\ i\ sum1\ sum2
comment43.target=int\ midDiff(int[],\ int,\ int,\ int)
comment44.params=minChess\ i\ j
comment44.target=int\ minPath(char[][],\ int,\ int)
comment44.text=\r\n\ moed\ 2016A\ moed\ 92\r\n\r\n\ This\ method\ calculates\ the\ minimum\ number\ of\ steps\ for\ a\ knight\ piece\ on\ a\ chessboard\r\n\ to\ reach\ a\ cell\ with\ the\ symbol\ 'K',\ starting\ from\ the\ cell\ at\ coordinates\ (i,\ j).\r\n\r\n\ @param\ minChess\ The\ chessboard\ represented\ as\ a\ 2D\ array\ of\ characters.\r\n\ @param\ i\ \ \ \ \ \ \ \ The\ row\ index\ of\ the\ starting\ cell.\r\n\ @param\ j\ \ \ \ \ \ \ \ The\ column\ index\ of\ the\ starting\ cell.\r\n\ @return\ \ \ \ \ \ \ \ \ The\ minimum\ number\ of\ steps\ required\ for\ the\ knight\ to\ reach\ the\ 'K'\ cell,\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ or\ -1\ if\ it's\ impossible\ to\ reach\ the\ 'K'\ cell\ from\ the\ starting\ cell.\r\n
comment45.params=minChess\ i\ j\ sum
comment45.target=int\ minPath(char[][],\ int,\ int,\ int)
comment46.params=m
comment46.target=int\ minPoints(int[][])
comment46.text=\r\n\ moed\ 2016A\ moed\ 83\r\n\r\n\ This\ method\ calculates\ the\ minimum\ number\ of\ points\ needed\ to\ traverse\ a\ matrix\ 'm'\r\n\ from\ the\ top-left\ corner\ to\ the\ bottom-right\ corner,\ allowing\ movements\ only\ to\ the\ right\ and\ down.\r\n\ Each\ cell\ of\ the\ matrix\ contributes\ points\ to\ the\ total,\ and\ if\ the\ total\ becomes\ negative,\r\n\ the\ method\ ensures\ that\ enough\ points\ are\ accumulated\ to\ keep\ the\ total\ non-negative.\r\n\r\n\ @param\ m\ The\ input\ matrix\ of\ integers.\r\n\ @return\ The\ minimum\ number\ of\ points\ needed\ to\ traverse\ the\ matrix.\r\n
comment47.params=m\ i\ j\ number\ sum
comment47.target=int\ minPoints(int[][],\ int,\ int,\ int,\ int)
comment5.params=n\ left\ right\ sequence
comment5.target=int\ countPairs(int,\ int,\ int,\ java.lang.String)
comment6.params=num\ result\ maxOp
comment6.target=int\ calc(int,\ int,\ int)
comment6.text=\r\n\ Recursive\ function\ to\ calculate\ expressions\ using\ the\ given\ number,\ result,\ and\ maximum\ number\ of\ operations.\r\n\ This\ exercise\ is\ from\ 2022B\ moed\ 96.\r\n\r\n\ @param\ num\ \ \ \ The\ number\ to\ use\ in\ the\ expressions.\r\n\ @param\ result\ The\ target\ result\ of\ the\ expressions.\r\n\ @param\ maxOp\ \ The\ maximum\ number\ of\ operations\ allowed.\r\n\ @return\ The\ number\ of\ valid\ expressions\ that\ yield\ the\ target\ result.\r\n
comment7.params=num\ result\ maxOp\ validOp\ sum
comment7.target=int\ calc(int,\ int,\ int,\ java.lang.String,\ int)
comment8.params=stations\ step1\ step2\ limit
comment8.target=int\ cheapRt(int[],\ int,\ int,\ int)
comment8.text=\r\n\ Recursive\ function\ to\ find\ the\ cheapest\ route\ among\ different\ stations.\r\n\ This\ exercise\ is\ from\ 2022B\ moed\ 96.\r\n\r\n\ @param\ stations\ The\ array\ representing\ the\ cost\ of\ each\ station.\r\n\ @param\ step1\ \ \ \ The\ step\ size\ for\ the\ first\ type\ of\ movement.\r\n\ @param\ step2\ \ \ \ The\ step\ size\ for\ the\ second\ type\ of\ movement.\r\n\ @param\ limit\ \ \ \ The\ limit\ on\ the\ number\ of\ steps.\r\n\ @return\ The\ cost\ of\ the\ cheapest\ route.\r\n
comment9.params=stations\ step1\ step2\ limit\ i\ path\ sum
comment9.target=int\ cheapRt(int[],\ int,\ int,\ int,\ int,\ java.lang.String,\ int)
numComments=48
